{
    "docs": [
        {
            "location": "/", 
            "text": "Redis graph\n\n\nIntroduction\n\n\nThis project is a Redis module that implements a graph database. Nodes in the graph represent entities such as persons or places, and connections such as 'visit' are made between the different entities.\n\n\nEntities may have multiple attributes, so Redis Hashes are optimal for storing them and a node in the graph is a Hash in the entity's key. For example, suppose we had a person entity representing Barack Obama. That entity's key in Redis would be \"Barack Obama\", and two of its fields could be \"age\" (55) and \"profession\" (ex-president). We could also have another entity under the key \"Hawaii\" with an attribute \"population\" (1442949).\n\n\nFinally we could construct a simple graph by connecting Barak Obama with an edge representing the relation \"born\" with Hawaii.\n\n\nThis is one of the key ideas behind this project; a node in the graph is simply a reference to an entity stored as Redis Hash.\n\n\nUsage\n\n\nThis module introduce four new commands\n- GRAPH.ADDEDGE\n- GRAPH.REMOVEEDGE\n- GRAPH.DELETE\n- GRAPH.QUERY\n\n\nGRAPH.ADDEDGE\n\n\nArguments: \nGraph name, source node, relationship, destination node\n\n\nCreats a connection within the given graph between source node and destination node using relation.\n\n\nGRAPH.ADDEDGE presidents \nBarak Obama\n born Hawaii\n\n\n\n\n\nGRAPH.REMOVEEDGE\n\n\nArguments: \nGraph name, source node, relationship, destination node\n\n\nRemoves edge connecting source to destination.\n\n\nGRAPH.REMOVEEDGE presidents \nRichard Nixon\n born California\n\n\n\n\n\nGRAPH.DELETE\n\n\nArguments: \nGraph name\n\n\nDeletes the entire graph\n\n\nGRAPH.DELETE presidents\n\n\n\n\n\nGRAPH.QUERY\n\n\nArguments: \nGraph name, Query\n\n\nExecute the given query against specified graph\n\n\nGRAPH.QUERY presidents \nMATCH (president)-[born]-\n(state:Hawaii) RETURN president.name, president.age\n\n\n\n\n\n\nQuery language\n\n\nThe syntax is based on neo4j's Cypher and currently only a subset of the language is supported.\n\n\nA query is composed of five parts:\n\n\nQuery structure\n\n\n\n\nMATCH\n\n\nWHERE\n\n\nRETURN\n\n\nORDER BY\n\n\nLIMIT\n\n\n\n\nMATCH\n\n\nDescribes the relationship between queried entities, it is composed of three parts:\n- Source node (S)\n- Relationship [R]\n- Destination node (D)\n\n\nCombining the three together\n\n(S)-[R]-\n(D)\n\n\nEach node can contain an alias and an entity ID, but nodes can be left empty if needed.\n\n\nNode structure: \n(alias:id)\n alias and id are both optional.\n\n\nExample:\n\n\n(\nactor\n)\n-\n[\nact\n]\n-\n(\nmovie:\nstraight outta compton\n)\n\n\n\n\n\n\nactor\n is an alias for the source node which we'll be able to refer to at different places within our query,\n\n\nact\n is the relationship\n\n\nAs such we're interested in entities which have the relation \"act\" with \nthe\n entity \"straight outta compton\"\n\n\nIt is possible to describe broder relationships by composing a multi hop query as such:\n\n\n(\nme:swilly\n)\n-\n[\nfriends_with\n]\n-\n()\n-\n[\nfriends_with\n]\n-\n(\nfof\n)\n\n\n\n\n\n\nHere we're interesed to find out who are my friends friends.\n\n\nNodes can have more than one edge coming in or out of them, for instance:\n\n\n(\nme:swilly\n)\n-\n[\nvisited\n]\n-\n(\ncountry\n)\n-\n[\nvisited\n]\n-\n(\nfriend\n)\n-\n[\nfriends_with\n]\n-\n(\nme\n)\n\n\n\n\n\n\nHere we're interested in knowing which of my friends have visited at least one country I've been to.\n\n\nWHERE\n\n\nThis clause is not mandatory, but in order to filter results you can define prediactes of two kinds:\n1. Compare against constant value: \nalias.property operation value\n\nwhere \nvalue\n is a primitive type (int, float, string and boolean)\n\n\n\n\nCompare between nodes properties: \nalias.property operation alias.property\n\n\n\n\nSupported operations:\n- \n=\n\n- \n!=\n\n- \n\n- \n=\n\n- \n\n- \n=\n\n\nPredicates can be combided using AND / OR, wrap predicates within parentheses to control precedence.\n\n\nExamples: \n\n\nWHERE \n(\nactor.name \n=\n \njohn doe\n OR movie.rating \n \n8\n.8\n)\n AND movie.votes \n=\n250\n)\n\n\n\n\n\n\nWHERE actor.age \n=\n director.age AND actor.age \n \n32\n\n\n\n\n\n\nRETURN\n\n\nIn its simple form Return defines which properties the returned result-set will contain,\nits structure is a list of \nalias.property\n seperated by comma, for convenience it's possible to specify\nonly alias. e.g.\n\n\nRETURN movie.title, actor\n\n\n\n\n\nUse the DISTINCT keyword to remove duplications within the result-set\n\n\nRETURN DISTINCT friend_of_friend.name\n\n\n\n\n\nIn the above example, suppose we have two friends Joe and Miesha\nand both know Dominick then DISTINCT will make sure Dominick will only appear once\nin the final result-set.\n\n\nReturn can also be used to aggregate data similar to SQL group by, once an aggregation function is added to the return list all other none aggregated values are considered as group keys, for example:\n\n\nRETURN movie.title, MAX\n(\nactor.age\n)\n, MIN\n(\nactor.age\n)\n\n\n\n\n\n\nHere we group data by movie title and foreach movie we find its youngest and oldest actor age.\n\n\nAggregations\n\n\nSupported aggregation functions:\n- \nsum\n\n- \navg\n\n- \nmin\n\n- \nmax\n\n- \ncount\n\n\nORDER BY\n\n\nSpecifies that the output should be sorted and how.\n\n\nYou can order by multiple properties by stating each variable in the ORDER BY clause.\nthe result will be sorted by the first variable listed, and for equals values, go to the next property in the ORDER BY clause, and so on.\n\n\nORDER BY \nalias.property list\n \n[\nASC/DESC\n]\n\n\n\n\n\n\nBelow we sort our friends by height, for similar heights, weight is used to break even.\n\n\nORDER BY friend.height, friend.weight DESC\n\n\n\n\n\nLIMIT\n\n\nAlthough not mandatory, but in order to limit the number of records returned by a query\nuse the limit clause as such\n\n\nLIMIT \nmax records to \nreturn\n\n\n\n\n\n\nIf not specified there's no limit to the number of records returned by a query.\n\n\nBuild and run\n\n\nTo build the module, from root folder run:\n\n\ncmake . \n make all\n\n\n\n\n\nLoading module into redis:\n\n\n# Assuming you have a redis build from the unstable branch:\n\n/path/to/redis-server --loadmodule \nPATH_TO_RedisGraph\n/src/libmodule.so\n\n\n\n\n\nFor more examples please see \nDemo", 
            "title": "RedisGraph"
        }, 
        {
            "location": "/#redis-graph", 
            "text": "", 
            "title": "Redis graph"
        }, 
        {
            "location": "/#introduction", 
            "text": "This project is a Redis module that implements a graph database. Nodes in the graph represent entities such as persons or places, and connections such as 'visit' are made between the different entities.  Entities may have multiple attributes, so Redis Hashes are optimal for storing them and a node in the graph is a Hash in the entity's key. For example, suppose we had a person entity representing Barack Obama. That entity's key in Redis would be \"Barack Obama\", and two of its fields could be \"age\" (55) and \"profession\" (ex-president). We could also have another entity under the key \"Hawaii\" with an attribute \"population\" (1442949).  Finally we could construct a simple graph by connecting Barak Obama with an edge representing the relation \"born\" with Hawaii.  This is one of the key ideas behind this project; a node in the graph is simply a reference to an entity stored as Redis Hash.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#usage", 
            "text": "This module introduce four new commands\n- GRAPH.ADDEDGE\n- GRAPH.REMOVEEDGE\n- GRAPH.DELETE\n- GRAPH.QUERY", 
            "title": "Usage"
        }, 
        {
            "location": "/#graphaddedge", 
            "text": "Arguments:  Graph name, source node, relationship, destination node  Creats a connection within the given graph between source node and destination node using relation.  GRAPH.ADDEDGE presidents  Barak Obama  born Hawaii", 
            "title": "GRAPH.ADDEDGE"
        }, 
        {
            "location": "/#graphremoveedge", 
            "text": "Arguments:  Graph name, source node, relationship, destination node  Removes edge connecting source to destination.  GRAPH.REMOVEEDGE presidents  Richard Nixon  born California", 
            "title": "GRAPH.REMOVEEDGE"
        }, 
        {
            "location": "/#graphdelete", 
            "text": "Arguments:  Graph name  Deletes the entire graph  GRAPH.DELETE presidents", 
            "title": "GRAPH.DELETE"
        }, 
        {
            "location": "/#graphquery", 
            "text": "Arguments:  Graph name, Query  Execute the given query against specified graph  GRAPH.QUERY presidents  MATCH (president)-[born]- (state:Hawaii) RETURN president.name, president.age", 
            "title": "GRAPH.QUERY"
        }, 
        {
            "location": "/#query-language", 
            "text": "The syntax is based on neo4j's Cypher and currently only a subset of the language is supported.  A query is composed of five parts:", 
            "title": "Query language"
        }, 
        {
            "location": "/#query-structure", 
            "text": "MATCH  WHERE  RETURN  ORDER BY  LIMIT", 
            "title": "Query structure"
        }, 
        {
            "location": "/#match", 
            "text": "Describes the relationship between queried entities, it is composed of three parts:\n- Source node (S)\n- Relationship [R]\n- Destination node (D)  Combining the three together (S)-[R]- (D)  Each node can contain an alias and an entity ID, but nodes can be left empty if needed.  Node structure:  (alias:id)  alias and id are both optional.  Example:  ( actor ) - [ act ] - ( movie: straight outta compton )   actor  is an alias for the source node which we'll be able to refer to at different places within our query,  act  is the relationship  As such we're interested in entities which have the relation \"act\" with  the  entity \"straight outta compton\"  It is possible to describe broder relationships by composing a multi hop query as such:  ( me:swilly ) - [ friends_with ] - () - [ friends_with ] - ( fof )   Here we're interesed to find out who are my friends friends.  Nodes can have more than one edge coming in or out of them, for instance:  ( me:swilly ) - [ visited ] - ( country ) - [ visited ] - ( friend ) - [ friends_with ] - ( me )   Here we're interested in knowing which of my friends have visited at least one country I've been to.", 
            "title": "MATCH"
        }, 
        {
            "location": "/#where", 
            "text": "This clause is not mandatory, but in order to filter results you can define prediactes of two kinds:\n1. Compare against constant value:  alias.property operation value \nwhere  value  is a primitive type (int, float, string and boolean)   Compare between nodes properties:  alias.property operation alias.property   Supported operations:\n-  = \n-  != \n-  \n-  = \n-  \n-  =  Predicates can be combided using AND / OR, wrap predicates within parentheses to control precedence.  Examples:   WHERE  ( actor.name  =   john doe  OR movie.rating    8 .8 )  AND movie.votes  = 250 )   WHERE actor.age  =  director.age AND actor.age    32", 
            "title": "WHERE"
        }, 
        {
            "location": "/#return", 
            "text": "In its simple form Return defines which properties the returned result-set will contain,\nits structure is a list of  alias.property  seperated by comma, for convenience it's possible to specify\nonly alias. e.g.  RETURN movie.title, actor  Use the DISTINCT keyword to remove duplications within the result-set  RETURN DISTINCT friend_of_friend.name  In the above example, suppose we have two friends Joe and Miesha\nand both know Dominick then DISTINCT will make sure Dominick will only appear once\nin the final result-set.  Return can also be used to aggregate data similar to SQL group by, once an aggregation function is added to the return list all other none aggregated values are considered as group keys, for example:  RETURN movie.title, MAX ( actor.age ) , MIN ( actor.age )   Here we group data by movie title and foreach movie we find its youngest and oldest actor age.", 
            "title": "RETURN"
        }, 
        {
            "location": "/#aggregations", 
            "text": "Supported aggregation functions:\n-  sum \n-  avg \n-  min \n-  max \n-  count", 
            "title": "Aggregations"
        }, 
        {
            "location": "/#order-by", 
            "text": "Specifies that the output should be sorted and how.  You can order by multiple properties by stating each variable in the ORDER BY clause.\nthe result will be sorted by the first variable listed, and for equals values, go to the next property in the ORDER BY clause, and so on.  ORDER BY  alias.property list   [ ASC/DESC ]   Below we sort our friends by height, for similar heights, weight is used to break even.  ORDER BY friend.height, friend.weight DESC", 
            "title": "ORDER BY"
        }, 
        {
            "location": "/#limit", 
            "text": "Although not mandatory, but in order to limit the number of records returned by a query\nuse the limit clause as such  LIMIT  max records to  return   If not specified there's no limit to the number of records returned by a query.", 
            "title": "LIMIT"
        }, 
        {
            "location": "/#build-and-run", 
            "text": "To build the module, from root folder run:  cmake .   make all  Loading module into redis:  # Assuming you have a redis build from the unstable branch: \n/path/to/redis-server --loadmodule  PATH_TO_RedisGraph /src/libmodule.so  For more examples please see  Demo", 
            "title": "Build and run"
        }, 
        {
            "location": "/design/", 
            "text": "RedisGraph: A High Performance In-Memory Graph Database as a Redis Module\n\n\nAbstract\n\n\nGraph based data is everywhere now days, Facebook, Google, Twitter and Pinterest are only a few who've realize the power behind relationship data and are utilizing it to the fullest, as a direct result we see a rise both in interest and variety of graph data solutions.\n\n\nWith the introduction of \nRedis Modules\n we've seen the great potential of introducing a graph data structure to Redis arsenal,\na native C implementation with emphasis on performance was developed to bring new graph database capabilities to Redis,\nthe \nRedisGraph\n is now available as an open source project on \nGitHub\n.\n\n\nIn this document we'll discuss the internal design and feature of RegisGraph and demonstrate its current capabilities.\n\n\nRediGraph At-a-Glance\n\n\nRediGraph is a graph database developed from scratch on top of Redis, using the new Redis Modules API to extend Redis with new commands and capabilities. Its main features include:\n- Simple, fast indexing and querying\n- Data stored in RAM, using memory-efficient custom data structures\n- On disk persistence\n- Tabular result sets\n- Simple and popular query language (Cypher)\n- Data Filtering, Aggregation and ordering\n\n\nA Little Taste: RediGraph in Action\n\n\nLet\u2019s look at some of the key concepts of RediGraph using this example over the redis-cli tool:\n\n\nIntroducing our entities:\n\n\nIt is a common concept to represent entities as nodes within a graph, RedisGraph follows this simple concept and utilize Redis native hash datatype to store its entities.\n\n\nIn this example, we'll create a small graph with both actors and movies as its entities, an \"act\" relation will connect actors to movies they casted in.\n\n\nWe use the HMSET command to create a new entity:\n\n\nHMSET \nentity_id\n \nattribute_name\n \nattribute_value\n \nattribute_name\n \nattribute_value\n ...\n\n\n\n\n\nOr in our example:\n\n\nHMSET Aldis_Hodge name \nAldis Hodge\n birth_year \n1986\n\nHMSET O\nShea_Jackson name \nO\nShea Jackson\n birth_year 1991\n\n\nHMSET Corey_Hawkins name \nCorey Hawkins\n birth_year 1988\n\n\nHMSET Neil_Brown name \nNeil Brown\n birthyear 1980\n\n\nHMSET Straight_Outta_Compton title \nStraight Outta Compton\n genre Biography votes 127258 rating 7.9 year 2015\n\n\nHMSET Never_Go_Back title \nNever Go Back\n gener Action votes 15821 rating 6.4 year 2016\n\n\n\n\n\n\nConnecting entities:\n\n\nIt is now time to form relationships between actors and movies, we use RedisGraph ADDEDGE command and specify the source entity, type of connection and destination entity as such:\n\n\nGRAPH.ADDEDGE \ngraph_id\n \nsrc_entity_id\n \nrelation\n \ndest_entity_id\n\n\n\n\n\n\nAdding the Straight Outta Compton cast:\n\n\nGRAPH.ADDEDGE movies Aldis_Hodge act Straight_Outta_Compton\nGRAPH.ADDEDGE movies O\nShea_Jackson act Straight_Outta_Compton\nGRAPH.ADDEDGE movies Corey_Hawkins act Straight_Outta_Compton\nGRAPH.ADDEDGE movies Neil_Brown act Straight_Outta_Compton\n\n\n\n\n\nAdding the only cast member who also played in the movie Never Go Back.\n\n\nGRAPH.ADDEDGE movies Aldis_Hodge act Never_Go_Back\n\n\n\n\n\nQuerying the graph:\n\n\nRedisGraph exposes a subset of Neo4J Cypher language, although only a number of language capabilities are supported there's enough functionality to extract valuable insights from your graphs, to execute a query we use the GRAPH.QUERY command:\n\n\nGRAPH.QUERY \ngraph_id\n \nquery\n\n\n\n\n\n\nLet's execute a number of queries against our movies graph:\n\n\nFind the sum, max, min and avg age of the Straight Outta Compton cast:\n\n\nGRAPH.QUERY movies \nMATCH (actor)-[act]-\n(movie:\nStraight_Outta_Compton\n) RETURN movie.title, SUM(actor.age), MAX(actor.age), MIN(actor.age), AVG(actor.age)\n\n\n\n\n\n\nRedisGraph will reply with:\n\n\n1\n)\n \nStraight Outta Compton,123.000000,37.000000,26.000000,30.750000\n\n\n2\n)\n \nQuery internal execution time: 0.108000 milliseconds\n\n\n\n\n\n\nThe first row contains our query result-set while the second row contains RedisGraph execution time.\n\n\nLet's try another query, this time we'll find in how many movies each actor played.\n\n\nGRAPH.QUERY movies \nMATCH (actor)-[act]-\n(movie) RETURN actor.name, COUNT(movie.title) AS movies_count ORDER BY movies_count DESC\n\n\n\n1\n)\n \nAldis_Hodge,2.000000\n\n\n2\n)\n \nO\nShea Jackson,1.000000\n\n\n3\n)\n \nCorey Hawkins,1.000000\n\n\n4\n)\n \nNeil Brown,1.000000\n\n\n5\n)\n \nQuery internal execution time: 0.071000 milliseconds\n\n\n\n\n\n\nThe Theory: Ideas behind RedisGraph\n\n\nDifferent graph databases uses different structures for representing a graph, some use adjacency list others might use an adjacency matrix, each with its advantages and disadvantages, For RedisGraph it was crucial to find a data structure which will enable us to perform fast searches on the graph, and so we're using a concept called Hexastore to hold all relationships within a graph.\n\n\nGraph representation: Hexastore\n\n\nA Hexastore is simply a list of triplets, where each triplet is composed of three parts:\n\n\n\n\nSubject\n\n\nPredicate\n\n\nObject\n\n\n\n\nWhere the Subject refers to a source node, Predicate represents a relationship and the Object refers to a destination node.\nFor each relationship within a graph our hexastore will contain all six permutation of the source node, relationship edge and destination node, for example consider the following relation:\n\n\n(Aldis_Hodge)-[act]-\n(Straight_Outta_Compton)\n\n\nAldis_Hodge is the source node\nact is the relationship\nand Straight_Outta_Compton is the destination node.\n\n\nAll six possibilities of representing this connection are as follows:\n\n\nSPO:Aldis_Hodge:act:Straight_Outta_Compton\nSOP:Aldis_Hodge:Straight_Outta_Compton:act\nPOS:act:Straight_Outta_Compton:Aldis_Hodge\nPSO:act:Aldis_Hodge:Straight_Outta_Compton\nOPS:Straight_Outta_Compton:act:Aldis_Hodge\nOSP:Straight_Outta_Compton:Aldis_Hodge:act\n\n\n\n\n\nWith the Hexastore constructed we can easily search our graph, suppose I would like to find the cast of the movie Straight Outta Compton, all I've to do is search my Hexastore for all strings containing the prefix: \nOPS:Straight_Outta_Compton:act:*\n\n\nOr if I'm interested in all the movies Aldis Hodge played in I can search for all strings containing the prefix: \nSPO:Aldis_Hodge:act:*\n\n\nAlthough a Hexastore uses plenty of memory, six triplets for each relation, we're using a trie data structure which is not only fast in terms of search but is also memory efficient as it doesn't create duplication of string prefixes it already seen.\n\n\nThe Design: Departing From Redis Data Structures\n\n\nAt first we stored the Hexastore within a Redis native sorted-set data structure, but with the ability of introducing new data structures to Redis we've switched to a trie, this allowed for more efficient search time and reduced the overall memory consumption.\n\n\nAs mentioned earlier nodes within the RedisGraph are no more than a reference to Redis hash object, these holds entities attributes, by using Redis Hashes we gain a number of nice features:\n- Fast insertion, Redis is known for its speed, creating hash objects (entities) is a quick operation to perform.\n- In case you've already got your entities stored in Redis there's no need for reintroducing them i.e. duplication, you can simply reuse them.\n- Data reusability, other Redis users which might not aware of RedisGraph can use these objects, that way RedisGraph enjoys \"Free\" updates to its entities.\n\n\nQuery language: Cypher\n\n\nThere are a number of Graph Query languages, we didn't want to reinvent the wheel and come up with our own language,\nand so we've decided to implement a subset of one of the most popular graph query language out there Cypher by Neo4J,\nthe Open-Cypher project provides means to create a parser for the language, although convenient\nwe decided to create our own parser with Lex as a tokenizer and Lemon which generates a C target parser.\n\n\nAs mentioned only a subset of the language is supported, but it is our intention to continue adding new capabilities and extend the language.\n\n\nRuntime: query execution\n\n\nLet's review the steps our module takes when executing a query,\nconsider the following query which finds all actors who've played alongside Aldis Hodge and are over 30 years old:\n\n\nMATCH (:Aldis_Hodge)-[act]-\n(Movie)\n-[act]-(Actor) WHERE Actor.age \n 30 RETURN Movie.title, Actor.name\n\n\n\n\n\nRediGraph will\n- Parse query, build abstract syntax tree (AST)\n- Build a graph representaion from the MATCH clause\n- Construct a filter tree\n- Search for matching entities\n- Populate result-set with matching entities attributes\n\n\nQuery parser\n\n\nGiven a valid query the parser will generate an AST containing four primary nodes one for each clause:\n\n\n\n\nMATCH\n\n\nWHERE\n\n\nRETURN\n\n\nORDER\n\n\n\n\nGenerating an abstract syntax tree is a common way of discribing and structuring a language.\n\n\nFilter tree\n\n\nA query can filter out entities by creating predicates, in our example we're filtering actors which are younger then 30.\nIt's possible to combined predicates using the OR, AND keywords to form granular conditions. during runtime the WHERE clause is used\nto construct a filter tree, each node within the tree is either a condition e.g. A \n B or an operation (AND/OR), candidate entities are passed\nthrough the tree and get evaluated.\n\n\nQuery processing\n\n\nThe MATCH clause describes relations between queried entities (nodes), a node can have an alias which will allow us to refer to it\nat later stages within the executing query lifetime (WHERE, RETURN clause), but all nodes must eventually be assign an ID,\nthe process of assigning IDs to nodes is refer to as the search phase.\n\n\nDuring the search we'll be querying the Hexastore for IDs according to the MATCH clause structure,\nfor instance in our example we'll start our search by looking for movies in which Aldis Hodge played in,\nfor each movie we'll extend our search to find out which other\nactors played in the current processed movie.\n\n\nIt makes sense to start searching from a node which already has an ID\nassigned to it, as this will reduce our search space dramatically,\nas you might imagine the search process is a recursive operation which traverse the graph, at each step a new ID is \ndiscovered, once every node has an ID assigned to it we can apply our filter tree to the graph and see if it passes all filters,\nif it dose we'll simply extract requested.\nattributes (as specified in the return clause) and append a new record to the final result set.\n\n\nBenchmarks:\n\n\nDepending on the underlying hardware results may vary, that said inserting a new relationship is done in O(1) RedisGraph is able to create 100K new relations within one second.\n\n\nRetrieving data really depends on the size of the graph and the type of query you're executing, on a small size graph ~1000 entities and ~2500 edges RedisGraph is able to perform ~30K friend of a friend query every second.\n\n\nIt's worth mentioning that besides the hexastore, entities are not indexed, it\u2019s our intention to introduce entities indexing which should decrease query execution time dramatically.\n\n\nLicense:\n\n\nRedis-Graph is published under AGPL-3.0.\n\n\nConclusion:\n\n\nRedisGraph although still a young project, can be an alternative to other graph databases, with its subset of operations one can use it to analyze and explore its graph data, being a Redis module this project is accessible from every Redis client without the need to make any adjustments. It's our intention to keep on improving and extending RedisGraph with the help of the open source community.", 
            "title": "Design"
        }, 
        {
            "location": "/design/#redisgraph-a-high-performance-in-memory-graph-database-as-a-redis-module", 
            "text": "", 
            "title": "RedisGraph: A High Performance In-Memory Graph Database as a Redis Module"
        }, 
        {
            "location": "/design/#abstract", 
            "text": "Graph based data is everywhere now days, Facebook, Google, Twitter and Pinterest are only a few who've realize the power behind relationship data and are utilizing it to the fullest, as a direct result we see a rise both in interest and variety of graph data solutions.  With the introduction of  Redis Modules  we've seen the great potential of introducing a graph data structure to Redis arsenal,\na native C implementation with emphasis on performance was developed to bring new graph database capabilities to Redis,\nthe  RedisGraph  is now available as an open source project on  GitHub .  In this document we'll discuss the internal design and feature of RegisGraph and demonstrate its current capabilities.", 
            "title": "Abstract"
        }, 
        {
            "location": "/design/#redigraph-at-a-glance", 
            "text": "RediGraph is a graph database developed from scratch on top of Redis, using the new Redis Modules API to extend Redis with new commands and capabilities. Its main features include:\n- Simple, fast indexing and querying\n- Data stored in RAM, using memory-efficient custom data structures\n- On disk persistence\n- Tabular result sets\n- Simple and popular query language (Cypher)\n- Data Filtering, Aggregation and ordering", 
            "title": "RediGraph At-a-Glance"
        }, 
        {
            "location": "/design/#a-little-taste-redigraph-in-action", 
            "text": "Let\u2019s look at some of the key concepts of RediGraph using this example over the redis-cli tool:", 
            "title": "A Little Taste: RediGraph in Action"
        }, 
        {
            "location": "/design/#introducing-our-entities", 
            "text": "It is a common concept to represent entities as nodes within a graph, RedisGraph follows this simple concept and utilize Redis native hash datatype to store its entities.  In this example, we'll create a small graph with both actors and movies as its entities, an \"act\" relation will connect actors to movies they casted in.  We use the HMSET command to create a new entity:  HMSET  entity_id   attribute_name   attribute_value   attribute_name   attribute_value  ...  Or in our example:  HMSET Aldis_Hodge name  Aldis Hodge  birth_year  1986 \nHMSET O Shea_Jackson name  O Shea Jackson  birth_year 1991  HMSET Corey_Hawkins name  Corey Hawkins  birth_year 1988  HMSET Neil_Brown name  Neil Brown  birthyear 1980  HMSET Straight_Outta_Compton title  Straight Outta Compton  genre Biography votes 127258 rating 7.9 year 2015  HMSET Never_Go_Back title  Never Go Back  gener Action votes 15821 rating 6.4 year 2016", 
            "title": "Introducing our entities:"
        }, 
        {
            "location": "/design/#connecting-entities", 
            "text": "It is now time to form relationships between actors and movies, we use RedisGraph ADDEDGE command and specify the source entity, type of connection and destination entity as such:  GRAPH.ADDEDGE  graph_id   src_entity_id   relation   dest_entity_id   Adding the Straight Outta Compton cast:  GRAPH.ADDEDGE movies Aldis_Hodge act Straight_Outta_Compton\nGRAPH.ADDEDGE movies O Shea_Jackson act Straight_Outta_Compton\nGRAPH.ADDEDGE movies Corey_Hawkins act Straight_Outta_Compton\nGRAPH.ADDEDGE movies Neil_Brown act Straight_Outta_Compton  Adding the only cast member who also played in the movie Never Go Back.  GRAPH.ADDEDGE movies Aldis_Hodge act Never_Go_Back", 
            "title": "Connecting entities:"
        }, 
        {
            "location": "/design/#querying-the-graph", 
            "text": "RedisGraph exposes a subset of Neo4J Cypher language, although only a number of language capabilities are supported there's enough functionality to extract valuable insights from your graphs, to execute a query we use the GRAPH.QUERY command:  GRAPH.QUERY  graph_id   query   Let's execute a number of queries against our movies graph:  Find the sum, max, min and avg age of the Straight Outta Compton cast:  GRAPH.QUERY movies  MATCH (actor)-[act]- (movie: Straight_Outta_Compton ) RETURN movie.title, SUM(actor.age), MAX(actor.age), MIN(actor.age), AVG(actor.age)   RedisGraph will reply with:  1 )   Straight Outta Compton,123.000000,37.000000,26.000000,30.750000  2 )   Query internal execution time: 0.108000 milliseconds   The first row contains our query result-set while the second row contains RedisGraph execution time.  Let's try another query, this time we'll find in how many movies each actor played.  GRAPH.QUERY movies  MATCH (actor)-[act]- (movie) RETURN actor.name, COUNT(movie.title) AS movies_count ORDER BY movies_count DESC  1 )   Aldis_Hodge,2.000000  2 )   O Shea Jackson,1.000000  3 )   Corey Hawkins,1.000000  4 )   Neil Brown,1.000000  5 )   Query internal execution time: 0.071000 milliseconds", 
            "title": "Querying the graph:"
        }, 
        {
            "location": "/design/#the-theory-ideas-behind-redisgraph", 
            "text": "Different graph databases uses different structures for representing a graph, some use adjacency list others might use an adjacency matrix, each with its advantages and disadvantages, For RedisGraph it was crucial to find a data structure which will enable us to perform fast searches on the graph, and so we're using a concept called Hexastore to hold all relationships within a graph.", 
            "title": "The Theory: Ideas behind RedisGraph"
        }, 
        {
            "location": "/design/#graph-representation-hexastore", 
            "text": "A Hexastore is simply a list of triplets, where each triplet is composed of three parts:   Subject  Predicate  Object   Where the Subject refers to a source node, Predicate represents a relationship and the Object refers to a destination node.\nFor each relationship within a graph our hexastore will contain all six permutation of the source node, relationship edge and destination node, for example consider the following relation:  (Aldis_Hodge)-[act]- (Straight_Outta_Compton)  Aldis_Hodge is the source node\nact is the relationship\nand Straight_Outta_Compton is the destination node.  All six possibilities of representing this connection are as follows:  SPO:Aldis_Hodge:act:Straight_Outta_Compton\nSOP:Aldis_Hodge:Straight_Outta_Compton:act\nPOS:act:Straight_Outta_Compton:Aldis_Hodge\nPSO:act:Aldis_Hodge:Straight_Outta_Compton\nOPS:Straight_Outta_Compton:act:Aldis_Hodge\nOSP:Straight_Outta_Compton:Aldis_Hodge:act  With the Hexastore constructed we can easily search our graph, suppose I would like to find the cast of the movie Straight Outta Compton, all I've to do is search my Hexastore for all strings containing the prefix:  OPS:Straight_Outta_Compton:act:*  Or if I'm interested in all the movies Aldis Hodge played in I can search for all strings containing the prefix:  SPO:Aldis_Hodge:act:*  Although a Hexastore uses plenty of memory, six triplets for each relation, we're using a trie data structure which is not only fast in terms of search but is also memory efficient as it doesn't create duplication of string prefixes it already seen.", 
            "title": "Graph representation: Hexastore"
        }, 
        {
            "location": "/design/#the-design-departing-from-redis-data-structures", 
            "text": "At first we stored the Hexastore within a Redis native sorted-set data structure, but with the ability of introducing new data structures to Redis we've switched to a trie, this allowed for more efficient search time and reduced the overall memory consumption.  As mentioned earlier nodes within the RedisGraph are no more than a reference to Redis hash object, these holds entities attributes, by using Redis Hashes we gain a number of nice features:\n- Fast insertion, Redis is known for its speed, creating hash objects (entities) is a quick operation to perform.\n- In case you've already got your entities stored in Redis there's no need for reintroducing them i.e. duplication, you can simply reuse them.\n- Data reusability, other Redis users which might not aware of RedisGraph can use these objects, that way RedisGraph enjoys \"Free\" updates to its entities.", 
            "title": "The Design: Departing From Redis Data Structures"
        }, 
        {
            "location": "/design/#query-language-cypher", 
            "text": "There are a number of Graph Query languages, we didn't want to reinvent the wheel and come up with our own language,\nand so we've decided to implement a subset of one of the most popular graph query language out there Cypher by Neo4J,\nthe Open-Cypher project provides means to create a parser for the language, although convenient\nwe decided to create our own parser with Lex as a tokenizer and Lemon which generates a C target parser.  As mentioned only a subset of the language is supported, but it is our intention to continue adding new capabilities and extend the language.", 
            "title": "Query language: Cypher"
        }, 
        {
            "location": "/design/#runtime-query-execution", 
            "text": "Let's review the steps our module takes when executing a query,\nconsider the following query which finds all actors who've played alongside Aldis Hodge and are over 30 years old:  MATCH (:Aldis_Hodge)-[act]- (Movie) -[act]-(Actor) WHERE Actor.age   30 RETURN Movie.title, Actor.name  RediGraph will\n- Parse query, build abstract syntax tree (AST)\n- Build a graph representaion from the MATCH clause\n- Construct a filter tree\n- Search for matching entities\n- Populate result-set with matching entities attributes", 
            "title": "Runtime: query execution"
        }, 
        {
            "location": "/design/#query-parser", 
            "text": "Given a valid query the parser will generate an AST containing four primary nodes one for each clause:   MATCH  WHERE  RETURN  ORDER   Generating an abstract syntax tree is a common way of discribing and structuring a language.", 
            "title": "Query parser"
        }, 
        {
            "location": "/design/#filter-tree", 
            "text": "A query can filter out entities by creating predicates, in our example we're filtering actors which are younger then 30.\nIt's possible to combined predicates using the OR, AND keywords to form granular conditions. during runtime the WHERE clause is used\nto construct a filter tree, each node within the tree is either a condition e.g. A   B or an operation (AND/OR), candidate entities are passed\nthrough the tree and get evaluated.", 
            "title": "Filter tree"
        }, 
        {
            "location": "/design/#query-processing", 
            "text": "The MATCH clause describes relations between queried entities (nodes), a node can have an alias which will allow us to refer to it\nat later stages within the executing query lifetime (WHERE, RETURN clause), but all nodes must eventually be assign an ID,\nthe process of assigning IDs to nodes is refer to as the search phase.  During the search we'll be querying the Hexastore for IDs according to the MATCH clause structure,\nfor instance in our example we'll start our search by looking for movies in which Aldis Hodge played in,\nfor each movie we'll extend our search to find out which other\nactors played in the current processed movie.  It makes sense to start searching from a node which already has an ID\nassigned to it, as this will reduce our search space dramatically,\nas you might imagine the search process is a recursive operation which traverse the graph, at each step a new ID is \ndiscovered, once every node has an ID assigned to it we can apply our filter tree to the graph and see if it passes all filters,\nif it dose we'll simply extract requested.\nattributes (as specified in the return clause) and append a new record to the final result set.", 
            "title": "Query processing"
        }, 
        {
            "location": "/design/#benchmarks", 
            "text": "Depending on the underlying hardware results may vary, that said inserting a new relationship is done in O(1) RedisGraph is able to create 100K new relations within one second.  Retrieving data really depends on the size of the graph and the type of query you're executing, on a small size graph ~1000 entities and ~2500 edges RedisGraph is able to perform ~30K friend of a friend query every second.  It's worth mentioning that besides the hexastore, entities are not indexed, it\u2019s our intention to introduce entities indexing which should decrease query execution time dramatically.", 
            "title": "Benchmarks:"
        }, 
        {
            "location": "/design/#license", 
            "text": "Redis-Graph is published under AGPL-3.0.", 
            "title": "License:"
        }, 
        {
            "location": "/design/#conclusion", 
            "text": "RedisGraph although still a young project, can be an alternative to other graph databases, with its subset of operations one can use it to analyze and explore its graph data, being a Redis module this project is accessible from every Redis client without the need to make any adjustments. It's our intention to keep on improving and extending RedisGraph with the help of the open source community.", 
            "title": "Conclusion:"
        }
    ]
}